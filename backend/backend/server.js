const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const Anthropic = require('@anthropic-ai/sdk');
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const PDFDocument = require('pdfkit');
const nodemailer = require('nodemailer');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3001;

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

// Anthropic client
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

// Email transporter
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});

// Generate PDF report as a Buffer
function generateReportPDF({ company_name, job_title, role_introduction, screening_questions, screening_url }) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const buffers = [];
    doc.on('data', (chunk) => buffers.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    const colors = { navy: '#1E293B', blue: '#2563EB', lightBlue: '#DBEAFE', gray: '#64748B', lightGray: '#F1F5F9', white: '#FFFFFF' };
    const pageWidth = doc.page.width;
    const contentWidth = pageWidth - 100;

    // Top accent bar
    doc.save();
    doc.fillColor(colors.blue).rect(0, 0, pageWidth, 8).fill();
    doc.restore();

    // Header area
    doc.moveDown(1.2);
    doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text('SCREENING PLATFORM', { align: 'left' });
    doc.moveDown(0.4);
    doc.fontSize(24).fillColor(colors.navy).font('Helvetica-Bold').text(company_name, { align: 'left' });
    doc.fontSize(14).fillColor(colors.blue).font('Helvetica').text(job_title, { align: 'left' });

    // Divider
    doc.moveDown(0.6);
    doc.save();
    doc.strokeColor(colors.blue).lineWidth(1.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();

    // Role Introduction box
    doc.moveDown(0.8);
    const introY = doc.y;
    doc.save();
    doc.fillColor(colors.lightBlue).roundedRect(50, introY, contentWidth, 80, 8).fill();
    doc.restore();
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('ROLE INTRODUCTION', { width: contentWidth - 24, align: 'left' }).moveDown(0.3);
    doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(role_introduction, { width: contentWidth - 24, align: 'left' });

    // Reposition below the box if text was short
    const afterIntro = introY + 80 + 20;
    if (doc.y < afterIntro) doc.y = afterIntro;

    // Screening Questions header
    doc.moveDown(0.3);
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('SCREENING QUESTIONS', { align: 'left' });
    doc.moveDown(0.5);

    // Questions list
    const questions = Array.isArray(screening_questions) ? screening_questions : JSON.parse(screening_questions);
    questions.forEach((q, i) => {
      const qY = doc.y;
      // Circle number badge
      doc.save();
      doc.fillColor(colors.blue).circle(62, qY + 8, 9).fill();
      doc.fillColor(colors.white).fontSize(9).font('Helvetica-Bold').text(`${i + 1}`, { width: 18, align: 'center' });
      doc.restore();
      // Question text
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(q, { x: 78, y: qY, width: contentWidth - 30, align: 'left' });
      doc.moveDown(0.6);
    });

    // Shareable link box
    doc.moveDown(0.6);
    const linkY = doc.y;
    doc.save();
    doc.fillColor(colors.lightGray).roundedRect(50, linkY, contentWidth, 55, 8).fill();
    doc.restore();
    doc.y = linkY + 12;
    doc.fontSize(9).fillColor(colors.gray).font('Helvetica-Bold').text('SHAREABLE SCREENING LINK', { x: 62, width: contentWidth - 24 }).moveDown(0.3);
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica').text(screening_url, { x: 62, width: contentWidth - 24, link: screening_url });

    // Footer
    doc.y = doc.page.height - 60;
    doc.save();
    doc.strokeColor('#E2E8F0').lineWidth(0.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();
    doc.moveDown(0.4);
    doc.fontSize(8).fillColor(colors.gray).font('Helvetica').text('Generated by Screening Platform  •  ' + new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }), { align: 'center' });

    doc.end();
  });
}

// Generate screening submission PDF as a Buffer
function generateScreeningResultPDF({ company_name, job_title, screening, role_specific_answers }) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const buffers = [];
    doc.on('data', (chunk) => buffers.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    const colors = { navy: '#1E293B', blue: '#2563EB', lightBlue: '#DBEAFE', gray: '#64748B', lightGray: '#F1F5F9', white: '#FFFFFF', green: '#16A34A', lightGreen: '#DCFCE7' };
    const pageWidth = doc.page.width;
    const contentWidth = pageWidth - 100;

    // Top accent bar
    doc.save();
    doc.fillColor(colors.green).rect(0, 0, pageWidth, 8).fill();
    doc.restore();

    // Header
    doc.moveDown(1.2);
    doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text('SCREENING PLATFORM', { align: 'left' });
    doc.moveDown(0.4);
    doc.fontSize(22).fillColor(colors.navy).font('Helvetica-Bold').text('Screening Submission', { align: 'left' });
    doc.fontSize(13).fillColor(colors.green).font('Helvetica').text(`${company_name}  —  ${job_title}`, { align: 'left' });

    // Divider
    doc.moveDown(0.6);
    doc.save();
    doc.strokeColor(colors.green).lineWidth(1.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();

    // Candidate details box
    doc.moveDown(0.8);
    const detailsY = doc.y;
    const details = [
      { label: 'Name', value: screening.candidate_name || '—' },
      { label: 'Email', value: screening.candidate_email || '—' },
      { label: 'Expected Salary', value: `${screening.expected_salary_amount} ${screening.expected_salary_currency}` },
      { label: 'Current Location', value: screening.current_location },
      { label: 'Work Preference', value: screening.work_preference },
      { label: 'Visa Status', value: screening.visa_status },
      { label: 'Availability', value: screening.notice_period_weeks ? `${screening.notice_period_weeks} weeks notice` : screening.availability_start_date || '—' }
    ];
    if (screening.visa_sponsorship_details) {
      details.splice(6, 0, { label: 'Sponsorship Details', value: screening.visa_sponsorship_details });
    }
    const boxHeight = 18 + details.length * 22;
    doc.save();
    doc.fillColor(colors.lightGray).roundedRect(50, detailsY, contentWidth, boxHeight, 8).fill();
    doc.restore();
    doc.fontSize(9).fillColor(colors.green).font('Helvetica-Bold').text('CANDIDATE DETAILS', { x: 62, y: detailsY + 10, width: contentWidth - 24 });
    details.forEach((d, i) => {
      const y = detailsY + 32 + i * 22;
      doc.fontSize(9).fillColor(colors.gray).font('Helvetica').text(d.label, { x: 62, y, width: contentWidth / 2 - 30 });
      doc.fontSize(9).fillColor(colors.navy).font('Helvetica-Bold').text(d.value, { x: contentWidth / 2 + 20, y, width: contentWidth / 2 - 20 });
    });
    doc.y = detailsY + boxHeight + 20;

    // Q&A section
    doc.moveDown(0.3);
    doc.fontSize(9).fillColor(colors.green).font('Helvetica-Bold').text('SCREENING QUESTIONS & ANSWERS', { align: 'left' });
    doc.moveDown(0.5);

    const answers = Array.isArray(role_specific_answers) ? role_specific_answers : JSON.parse(role_specific_answers);
    answers.forEach((qa, i) => {
      // Check if we need a new page
      if (doc.y > doc.page.height - 100) {
        doc.addPage();
        doc.y = 50;
      }
      const qY = doc.y;
      // Circle badge
      doc.save();
      doc.fillColor(colors.green).circle(62, qY + 8, 9).fill();
      doc.fillColor(colors.white).fontSize(9).font('Helvetica-Bold').text(`${i + 1}`, { x: 55, y: qY + 3, width: 14, align: 'center' });
      doc.restore();
      // Question
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica-Bold').text(qa.question, { x: 78, y: qY, width: contentWidth - 30 });
      const ansY = doc.y + 2;
      // Answer
      doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text(qa.answer || '—', { x: 78, y: ansY, width: contentWidth - 30 });
      doc.moveDown(0.8);
    });

    // Recruiter notes
    if (screening.recruiter_notes) {
      if (doc.y > doc.page.height - 120) { doc.addPage(); doc.y = 50; }
      doc.moveDown(0.4);
      const notesY = doc.y;
      doc.save();
      doc.fillColor(colors.lightBlue).roundedRect(50, notesY, contentWidth, 70, 8).fill();
      doc.restore();
      doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('RECRUITER NOTES', { x: 62, y: notesY + 10, width: contentWidth - 24 });
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(screening.recruiter_notes, { x: 62, y: notesY + 30, width: contentWidth - 24 });
      doc.y = notesY + 80;
    }

    // Footer
    doc.y = doc.page.height - 60;
    doc.save();
    doc.strokeColor('#E2E8F0').lineWidth(0.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();
    doc.moveDown(0.4);
    doc.fontSize(8).fillColor(colors.gray).font('Helvetica').text('Generated by Screening Platform  •  ' + new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }), { align: 'center' });

    doc.end();
  });
}

app.use(cors({ origin: process.env.FRONTEND_URL }));
app.use(express.json());

// Ensure users table exists
(async () => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        created_at TIMESTAMPTZ DEFAULT NOW()
      )
    `);
  } catch (e) {
    console.error('Failed to create users table:', e.message);
  }
})();

// JWT middleware
function verifyToken(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  try {
    req.user = jwt.verify(auth.split(' ')[1], process.env.JWT_SECRET);
    next();
  } catch {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Auth: check if any users exist
app.get('/api/auth/status', async (req, res) => {
  try {
    const { rows } = await pool.query('SELECT COUNT(*)::int AS count FROM users');
    res.json({ hasUsers: rows[0].count > 0 });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// Auth: register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
    if (!email.endsWith('@starcircle.com')) return res.status(403).json({ error: 'Only @starcircle.com emails are allowed' });

    const hashed = await bcrypt.hash(password, 10);
    await pool.query('INSERT INTO users (email, password) VALUES ($1, $2)', [email, hashed]);

    const token = jwt.sign({ email }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, email });
  } catch (e) {
    if (e.code === '23505') return res.status(409).json({ error: 'Email already registered' });
    res.status(500).json({ error: e.message });
  }
});

// Auth: login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });

    const { rows } = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (rows.length === 0) return res.status(401).json({ error: 'Invalid email or password' });

    const valid = await bcrypt.compare(password, rows[0].password);
    if (!valid) return res.status(401).json({ error: 'Invalid email or password' });

    const token = jwt.sign({ email }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, email });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// CREATE ROLE + GENERATE QUESTIONS
app.post('/api/roles', verifyToken, async (req, res) => {
  try {
    const { company_name, job_title, job_description, notification_email, selected_questions } = req.body;
    const preSelected = Array.isArray(selected_questions) ? selected_questions : [];
    const remaining = Math.max(0, 6 - preSelected.length);

    // Generate AI content
    let prompt = `You are an expert recruiter designing screening questions for a 15-minute phone call. Keep each question simple and conversational — something that can be answered in under 2 minutes.

Job Title: ${job_title}

Job Description:
${job_description}
`;

    if (preSelected.length > 0 && remaining > 0) {
      prompt += `
The following questions have already been selected and will be included in the screening. Do NOT repeat or rephrase them:
${preSelected.map((q, i) => `${i + 1}. ${q}`).join('\n')}

Generate exactly ${remaining} additional screening questions that complement the ones above. Focus on role-specific skills and experience.
`;
    } else if (preSelected.length === 0) {
      prompt += `
Generate 6 screening questions. Keep them straightforward and easy to answer in under 2 minutes each.
`;
    }

    prompt += `
Also generate a 2-3 sentence role introduction that excites candidates.

Respond ONLY with valid JSON in this exact format:
{
  "role_introduction": "...",
  "screening_questions": ["Q1", "Q2", ...]
}`;

    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 1000,
      messages: [{ role: 'user', content: prompt }]
    });

    const responseText = message.content[0].text;
    const cleanJson = responseText.replace(/```json|```/g, '').trim();
    const aiContent = JSON.parse(cleanJson);

    // Merge: user-selected first, then AI-generated
    const allQuestions = [...preSelected, ...aiContent.screening_questions];

    // Generate unique URL slug
    const url_slug = `${company_name.toLowerCase().replace(/\s+/g, '-')}-${crypto.randomBytes(6).toString('base64url')}`;

    // Save to database
    const result = await pool.query(
      `INSERT INTO roles (company_name, job_title, job_description, role_introduction, screening_questions, url_slug, notification_email)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [
        company_name,
        job_title,
        job_description,
        aiContent.role_introduction,
        JSON.stringify(allQuestions),
        url_slug,
        notification_email
      ]
    );

    const role = result.rows[0];
    const screening_url = `${process.env.FRONTEND_URL}/screen/${role.url_slug}`;

    res.json({
      role_id: role.id,
      url_slug: role.url_slug,
      screening_url,
      role_introduction: role.role_introduction,
      screening_questions: role.screening_questions
    });

    // Fire-and-forget: generate PDF and email it
    (async () => {
      try {
        const pdfBuffer = await generateReportPDF({
          company_name: role.company_name,
          job_title: role.job_title,
          role_introduction: role.role_introduction,
          screening_questions: role.screening_questions,
          screening_url
        });

        await transporter.sendMail({
          from: `"Screening Platform" <${process.env.SMTP_USER}>`,
          to: notification_email,
          subject: `Screening Created — ${role.job_title} at ${role.company_name}`,
          html: `
            <div style="font-family: system-ui, sans-serif; max-width: 560px; margin: 0 auto; padding: 32px 24px; color: #1E293B;">
              <div style="border-top: 4px solid #2563EB; padding-top: 24px; margin-bottom: 24px;"></div>
              <h1 style="font-size: 22px; margin: 0 0 4px;">Screening Created</h1>
              <p style="color: #64748B; margin: 0 0 24px; font-size: 14px;">Your new screening is ready to share.</p>

              <div style="background: #F1F5F9; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Company</p>
                <p style="margin: 0 0 12px; font-size: 15px; font-weight: 600;">${role.company_name}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Job Title</p>
                <p style="margin: 0; font-size: 15px; font-weight: 600;">${role.job_title}</p>
              </div>

              <p style="font-size: 14px; color: #64748B; margin: 0 0 8px;">Shareable screening link:</p>
              <a href="${screening_url}" style="display: block; background: #DBEAFE; color: #2563EB; padding: 10px 16px; border-radius: 6px; font-size: 13px; text-decoration: none; word-break: break-all;">${screening_url}</a>

              <p style="font-size: 13px; color: #94A3B8; margin: 32px 0 0; border-top: 1px solid #E2E8F0; padding-top: 16px;">
                A full PDF report is attached. Generated by Screening Platform.
              </p>
            </div>
          `,
          attachments: [
            {
              filename: `${role.company_name.replace(/\s+/g, '-')}_${role.job_title.replace(/\s+/g, '-')}_screening.pdf`,
              content: pdfBuffer,
              contentType: 'application/pdf'
            }
          ]
        });

        console.log(`PDF report emailed to ${notification_email}`);
      } catch (emailErr) {
        console.error('Failed to send PDF email:', emailErr.message);
      }
    })();

  } catch (error) {
    console.error('Error creating role:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET ROLE BY SLUG
app.get('/api/roles/:slug', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM roles WHERE url_slug = $1',
      [req.params.slug]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Role not found' });
    }

    const role = result.rows[0];
    res.json({
      role_id: role.id,
      company_name: role.company_name,
      job_title: role.job_title,
      role_introduction: role.role_introduction,
      screening_questions: role.screening_questions
    });

  } catch (error) {
    console.error('Error fetching role:', error);
    res.status(500).json({ error: error.message });
  }
});

// UPDATE ROLE (intro / questions)
app.patch('/api/roles/:id', verifyToken, async (req, res) => {
  try {
    const { role_introduction, screening_questions } = req.body;
    const sets = [];
    const values = [];
    let idx = 1;

    if (role_introduction !== undefined) {
      sets.push(`role_introduction = $${idx++}`);
      values.push(role_introduction);
    }
    if (screening_questions !== undefined) {
      sets.push(`screening_questions = $${idx++}`);
      values.push(JSON.stringify(screening_questions));
    }

    if (sets.length === 0) return res.status(400).json({ error: 'Nothing to update' });

    values.push(req.params.id);
    await pool.query(`UPDATE roles SET ${sets.join(', ')} WHERE id = $${idx}`, values);

    res.json({ status: 'updated' });
  } catch (error) {
    console.error('Error updating role:', error);
    res.status(500).json({ error: error.message });
  }
});

// SUBMIT SCREENING
app.post('/api/screenings', async (req, res) => {
  try {
    const {
      role_id,
      candidate_name,
      candidate_email,
      expected_salary_amount,
      expected_salary_currency,
      current_location,
      work_preference,
      visa_status,
      visa_sponsorship_details,
      notice_period_weeks,
      availability_start_date,
      role_specific_answers,
      recruiter_notes,
      recruiter_email
    } = req.body;

    const result = await pool.query(
      `INSERT INTO screenings (
        role_id, candidate_name, candidate_email,
        expected_salary_amount, expected_salary_currency,
        current_location, work_preference, visa_status,
        visa_sponsorship_details, notice_period_weeks,
        availability_start_date, role_specific_answers,
        recruiter_notes, recruiter_email
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      RETURNING *`,
      [
        role_id,
        candidate_name,
        candidate_email,
        expected_salary_amount,
        expected_salary_currency,
        current_location,
        work_preference,
        visa_status,
        visa_sponsorship_details,
        notice_period_weeks,
        availability_start_date,
        JSON.stringify(role_specific_answers),
        recruiter_notes,
        recruiter_email
      ]
    );

    res.json({
      screening_id: result.rows[0].id,
      status: 'submitted',
      submitted_at: result.rows[0].submitted_at
    });

    // Fire-and-forget: fetch role, generate PDF, email to notification_email
    (async () => {
      try {
        const roleResult = await pool.query('SELECT * FROM roles WHERE id = $1', [role_id]);
        if (roleResult.rows.length === 0) return;
        const role = roleResult.rows[0];
        if (!role.notification_email) return;

        const screening = result.rows[0];
        const pdfBuffer = await generateScreeningResultPDF({
          company_name: role.company_name,
          job_title: role.job_title,
          screening,
          role_specific_answers
        });

        await transporter.sendMail({
          from: `"Screening Platform" <${process.env.SMTP_USER}>`,
          to: role.notification_email,
          subject: `New Screening Submission — ${candidate_name} for ${role.job_title} at ${role.company_name}`,
          html: `
            <div style="font-family: system-ui, sans-serif; max-width: 560px; margin: 0 auto; padding: 32px 24px; color: #1E293B;">
              <div style="border-top: 4px solid #16A34A; padding-top: 24px; margin-bottom: 24px;"></div>
              <h1 style="font-size: 22px; margin: 0 0 4px;">New Screening Submission</h1>
              <p style="color: #64748B; margin: 0 0 24px; font-size: 14px;">A candidate has completed the screening.</p>

              <div style="background: #F1F5F9; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Candidate</p>
                <p style="margin: 0 0 4px; font-size: 15px; font-weight: 600;">${candidate_name}</p>
                <p style="margin: 0 0 12px; font-size: 13px; color: #2563EB;">${candidate_email}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Role</p>
                <p style="margin: 0; font-size: 15px; font-weight: 600;">${role.job_title} at ${role.company_name}</p>
              </div>

              <p style="font-size: 13px; color: #94A3B8; margin: 24px 0 0; border-top: 1px solid #E2E8F0; padding-top: 16px;">
                Full screening details are attached as a PDF. Generated by Screening Platform.
              </p>
            </div>
          `,
          attachments: [
            {
              filename: `${candidate_name.replace(/\s+/g, '-')}_${role.job_title.replace(/\s+/g, '-')}_submission.pdf`,
              content: pdfBuffer,
              contentType: 'application/pdf'
            }
          ]
        });

        console.log(`Screening submission PDF emailed to ${role.notification_email}`);
      } catch (emailErr) {
        console.error('Failed to send screening submission email:', emailErr.message);
      }
    })();

  } catch (error) {
    console.error('Error submitting screening:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET ALL SCREENINGS FOR A ROLE
app.get('/api/screenings/role/:roleId', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM screenings WHERE role_id = $1 ORDER BY submitted_at DESC',
      [req.params.roleId]
    );

    res.json({ screenings: result.rows });

  } catch (error) {
    console.error('Error fetching screenings:', error);
    res.status(500).json({ error: error.message });
  }
});

app.listen(port, () => {
  console.log(`✅ Backend running on http://localhost:${port}`);
});