const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const Anthropic = require('@anthropic-ai/sdk');
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const PDFDocument = require('pdfkit');
const nodemailer = require('nodemailer');
const multer = require('multer');
const OpenAI = require('openai');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3001;

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

// Anthropic client
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

// Email transporter
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});

// Multer — in-memory storage, max 25 MB (Whisper limit)
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 25 * 1024 * 1024 } });

// Generate PDF report as a Buffer
function generateReportPDF({ company_name, job_title, role_introduction, screening_questions, screening_url }) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const buffers = [];
    doc.on('data', (chunk) => buffers.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    const colors = { navy: '#1E293B', blue: '#2563EB', lightBlue: '#DBEAFE', gray: '#64748B', lightGray: '#F1F5F9', white: '#FFFFFF' };
    const pageWidth = doc.page.width;
    const contentWidth = pageWidth - 100;

    // Top accent bar
    doc.save();
    doc.fillColor(colors.blue).rect(0, 0, pageWidth, 8).fill();
    doc.restore();

    // Header area
    doc.moveDown(1.2);
    doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text('SCREENING PLATFORM', { align: 'left' });
    doc.moveDown(0.4);
    doc.fontSize(24).fillColor(colors.navy).font('Helvetica-Bold').text(company_name, { align: 'left' });
    doc.fontSize(14).fillColor(colors.blue).font('Helvetica').text(job_title, { align: 'left' });

    // Divider
    doc.moveDown(0.6);
    doc.save();
    doc.strokeColor(colors.blue).lineWidth(1.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();

    // Role Introduction box
    doc.moveDown(0.8);
    const introY = doc.y;
    doc.save();
    doc.fillColor(colors.lightBlue).roundedRect(50, introY, contentWidth, 80, 8).fill();
    doc.restore();
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('ROLE INTRODUCTION', { width: contentWidth - 24, align: 'left' }).moveDown(0.3);
    doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(role_introduction, { width: contentWidth - 24, align: 'left' });

    // Reposition below the box if text was short
    const afterIntro = introY + 80 + 20;
    if (doc.y < afterIntro) doc.y = afterIntro;

    // Screening Questions header
    doc.moveDown(0.3);
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('SCREENING QUESTIONS', { align: 'left' });
    doc.moveDown(0.5);

    // Questions list
    const questions = Array.isArray(screening_questions) ? screening_questions : JSON.parse(screening_questions);
    questions.forEach((q, i) => {
      const qY = doc.y;
      // Circle number badge
      doc.save();
      doc.fillColor(colors.blue).circle(62, qY + 8, 9).fill();
      doc.fillColor(colors.white).fontSize(9).font('Helvetica-Bold').text(`${i + 1}`, { width: 18, align: 'center' });
      doc.restore();
      // Question text
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(q, { x: 78, y: qY, width: contentWidth - 30, align: 'left' });
      doc.moveDown(0.6);
    });

    // Shareable link box
    doc.moveDown(0.6);
    const linkY = doc.y;
    doc.save();
    doc.fillColor(colors.lightGray).roundedRect(50, linkY, contentWidth, 55, 8).fill();
    doc.restore();
    doc.y = linkY + 12;
    doc.fontSize(9).fillColor(colors.gray).font('Helvetica-Bold').text('SHAREABLE SCREENING LINK', { x: 62, width: contentWidth - 24 }).moveDown(0.3);
    doc.fontSize(9).fillColor(colors.blue).font('Helvetica').text(screening_url, { x: 62, width: contentWidth - 24, link: screening_url });

    // Footer
    doc.y = doc.page.height - 60;
    doc.save();
    doc.strokeColor('#E2E8F0').lineWidth(0.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();
    doc.moveDown(0.4);
    doc.fontSize(8).fillColor(colors.gray).font('Helvetica').text('Generated by Screening Platform  •  ' + new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }), { align: 'center' });

    doc.end();
  });
}

// Generate screening submission PDF as a Buffer
function generateScreeningResultPDF({ company_name, job_title, screening, role_specific_answers }) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const buffers = [];
    doc.on('data', (chunk) => buffers.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    const colors = { navy: '#1E293B', blue: '#2563EB', lightBlue: '#DBEAFE', gray: '#64748B', lightGray: '#F1F5F9', white: '#FFFFFF', green: '#16A34A', lightGreen: '#DCFCE7' };
    const pageWidth = doc.page.width;
    const contentWidth = pageWidth - 100;

    // Top accent bar
    doc.save();
    doc.fillColor(colors.green).rect(0, 0, pageWidth, 8).fill();
    doc.restore();

    // Header
    doc.moveDown(1.2);
    doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text('SCREENING PLATFORM', { align: 'left' });
    doc.moveDown(0.4);
    doc.fontSize(22).fillColor(colors.navy).font('Helvetica-Bold').text('Screening Submission', { align: 'left' });
    doc.fontSize(13).fillColor(colors.green).font('Helvetica').text(`${company_name}  —  ${job_title}`, { align: 'left' });

    // Divider
    doc.moveDown(0.6);
    doc.save();
    doc.strokeColor(colors.green).lineWidth(1.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();

    // Candidate details box
    doc.moveDown(0.8);
    const detailsY = doc.y;
    const details = [
      { label: 'Name', value: screening.candidate_name || '—' },
      { label: 'Email', value: screening.candidate_email || '—' },
      { label: 'Expected Salary', value: `${screening.expected_salary_amount} ${screening.expected_salary_currency}` },
      { label: 'Current Location', value: screening.current_location },
      { label: 'Work Preference', value: screening.work_preference },
      { label: 'Visa Status', value: screening.visa_status },
      { label: 'Availability', value: screening.notice_period_weeks ? `${screening.notice_period_weeks} weeks notice` : screening.availability_start_date || '—' }
    ];
    if (screening.visa_sponsorship_details) {
      details.splice(6, 0, { label: 'Sponsorship Details', value: screening.visa_sponsorship_details });
    }
    const boxHeight = 18 + details.length * 22;
    doc.save();
    doc.fillColor(colors.lightGray).roundedRect(50, detailsY, contentWidth, boxHeight, 8).fill();
    doc.restore();
    doc.fontSize(9).fillColor(colors.green).font('Helvetica-Bold').text('CANDIDATE DETAILS', { x: 62, y: detailsY + 10, width: contentWidth - 24 });
    details.forEach((d, i) => {
      const y = detailsY + 32 + i * 22;
      doc.fontSize(9).fillColor(colors.gray).font('Helvetica').text(d.label, { x: 62, y, width: contentWidth / 2 - 30 });
      doc.fontSize(9).fillColor(colors.navy).font('Helvetica-Bold').text(d.value, { x: contentWidth / 2 + 20, y, width: contentWidth / 2 - 20 });
    });
    doc.y = detailsY + boxHeight + 20;

    // Q&A section
    doc.moveDown(0.3);
    doc.fontSize(9).fillColor(colors.green).font('Helvetica-Bold').text('SCREENING QUESTIONS & ANSWERS', { align: 'left' });
    doc.moveDown(0.5);

    const answers = Array.isArray(role_specific_answers) ? role_specific_answers : JSON.parse(role_specific_answers);
    answers.forEach((qa, i) => {
      // Check if we need a new page
      if (doc.y > doc.page.height - 100) {
        doc.addPage();
        doc.y = 50;
      }
      const qY = doc.y;
      // Circle badge
      doc.save();
      doc.fillColor(colors.green).circle(62, qY + 8, 9).fill();
      doc.fillColor(colors.white).fontSize(9).font('Helvetica-Bold').text(`${i + 1}`, { x: 55, y: qY + 3, width: 14, align: 'center' });
      doc.restore();
      // Question
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica-Bold').text(qa.question, { x: 78, y: qY, width: contentWidth - 30 });
      const ansY = doc.y + 2;
      // Answer
      doc.fontSize(10).fillColor(colors.gray).font('Helvetica').text(qa.answer || '—', { x: 78, y: ansY, width: contentWidth - 30 });
      doc.moveDown(0.8);
    });

    // Recruiter notes
    if (screening.recruiter_notes) {
      if (doc.y > doc.page.height - 120) { doc.addPage(); doc.y = 50; }
      doc.moveDown(0.4);
      const notesY = doc.y;
      doc.save();
      doc.fillColor(colors.lightBlue).roundedRect(50, notesY, contentWidth, 70, 8).fill();
      doc.restore();
      doc.fontSize(9).fillColor(colors.blue).font('Helvetica-Bold').text('RECRUITER NOTES', { x: 62, y: notesY + 10, width: contentWidth - 24 });
      doc.fontSize(10).fillColor(colors.navy).font('Helvetica').text(screening.recruiter_notes, { x: 62, y: notesY + 30, width: contentWidth - 24 });
      doc.y = notesY + 80;
    }

    // Footer
    doc.y = doc.page.height - 60;
    doc.save();
    doc.strokeColor('#E2E8F0').lineWidth(0.5).moveTo(50, doc.y).lineTo(pageWidth - 50, doc.y).stroke();
    doc.restore();
    doc.moveDown(0.4);
    doc.fontSize(8).fillColor(colors.gray).font('Helvetica').text('Generated by Screening Platform  •  ' + new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }), { align: 'center' });

    doc.end();
  });
}

app.use(cors({ origin: process.env.FRONTEND_URL }));
app.use(express.json());

// Ensure tables exist / migrate
(async () => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        created_at TIMESTAMPTZ DEFAULT NOW()
      )
    `);
    // Add status column to roles if missing
    await pool.query(`ALTER TABLE roles ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'open'`);
    // Availability + bookings
    await pool.query(`
      CREATE TABLE IF NOT EXISTS availability (
        user_email TEXT PRIMARY KEY,
        days INTEGER[] NOT NULL DEFAULT '{}',
        start_hour INTEGER NOT NULL DEFAULT 9,
        end_hour INTEGER NOT NULL DEFAULT 17
      )
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS bookings (
        id SERIAL PRIMARY KEY,
        role_id TEXT NOT NULL,
        recruiter_email TEXT NOT NULL,
        candidate_name TEXT NOT NULL,
        candidate_email TEXT NOT NULL,
        booked_date TEXT NOT NULL,
        booked_time TEXT NOT NULL,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(recruiter_email, booked_date, booked_time)
      )
    `);
    // Migrate role_id from INTEGER to TEXT if table already existed
    await pool.query(`ALTER TABLE bookings ALTER COLUMN role_id TYPE TEXT`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS meet_link TEXT`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS transcript TEXT`);
  } catch (e) {
    console.error('Failed during migration:', e.message);
  }
})();

// JWT middleware
function verifyToken(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  try {
    req.user = jwt.verify(auth.split(' ')[1], process.env.JWT_SECRET);
    next();
  } catch {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Auth: check if any users exist
app.get('/api/auth/status', async (req, res) => {
  try {
    const { rows } = await pool.query('SELECT COUNT(*)::int AS count FROM users');
    res.json({ hasUsers: rows[0].count > 0 });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// Auth: register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
    if (!email.endsWith('@starcircle.com')) return res.status(403).json({ error: 'Only @starcircle.com emails are allowed' });

    const hashed = await bcrypt.hash(password, 10);
    await pool.query('INSERT INTO users (email, password) VALUES ($1, $2)', [email, hashed]);

    const token = jwt.sign({ email }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, email });
  } catch (e) {
    if (e.code === '23505') return res.status(409).json({ error: 'Email already registered' });
    res.status(500).json({ error: e.message });
  }
});

// Auth: login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });

    const { rows } = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (rows.length === 0) return res.status(401).json({ error: 'Invalid email or password' });

    const valid = await bcrypt.compare(password, rows[0].password);
    if (!valid) return res.status(401).json({ error: 'Invalid email or password' });

    const token = jwt.sign({ email }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, email });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// CREATE ROLE + GENERATE QUESTIONS
app.post('/api/roles', verifyToken, async (req, res) => {
  try {
    const { company_name, job_title, job_description, selected_questions } = req.body;
    const notification_email = req.user.email;
    const preSelected = Array.isArray(selected_questions) ? selected_questions : [];
    const remaining = Math.max(0, 6 - preSelected.length);

    // Generate AI content
    let prompt = `You are an expert recruiter designing screening questions for a 15-minute phone call. Keep each question simple and conversational — something that can be answered in under 2 minutes.

Job Title: ${job_title}

Job Description:
${job_description}
`;

    if (preSelected.length > 0 && remaining > 0) {
      prompt += `
The following questions have already been selected and will be included in the screening. Do NOT repeat or rephrase them:
${preSelected.map((q, i) => `${i + 1}. ${q}`).join('\n')}

Generate exactly ${remaining} additional screening questions that complement the ones above. Focus on role-specific skills and experience.
`;
    } else if (preSelected.length === 0) {
      prompt += `
Generate 6 screening questions. Keep them straightforward and easy to answer in under 2 minutes each.
`;
    }

    prompt += `
Also generate an introduction for the candidate. It should have two parts:
1. A brief company overview (2-3 sentences about the company, inferred from the job description context — what they do, their mission, culture).
2. A brief role overview (2-3 sentences about this specific position and what makes it exciting).

Write both parts as flowing prose (no headings or labels), with the company overview first and the role overview second, separated by a paragraph break.

Respond ONLY with valid JSON in this exact format:
{
  "role_introduction": "...",
  "screening_questions": ["Q1", "Q2", ...]
}`;

    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 1000,
      messages: [{ role: 'user', content: prompt }]
    });

    const responseText = message.content[0].text;
    const cleanJson = responseText.replace(/```json|```/g, '').trim();
    const aiContent = JSON.parse(cleanJson);

    // Merge: user-selected first, then AI-generated
    const allQuestions = [...preSelected, ...aiContent.screening_questions];

    // Generate unique URL slug
    const url_slug = `${company_name.toLowerCase().replace(/\s+/g, '-')}-${crypto.randomBytes(6).toString('base64url')}`;

    // Save to database
    const result = await pool.query(
      `INSERT INTO roles (company_name, job_title, job_description, role_introduction, screening_questions, url_slug, notification_email)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [
        company_name,
        job_title,
        job_description,
        aiContent.role_introduction,
        JSON.stringify(allQuestions),
        url_slug,
        notification_email
      ]
    );

    const role = result.rows[0];
    const screening_url = `${process.env.FRONTEND_URL}/screen/${role.url_slug}`;

    res.json({
      role_id: role.id,
      url_slug: role.url_slug,
      screening_url,
      role_introduction: role.role_introduction,
      screening_questions: role.screening_questions
    });

    // Fire-and-forget: generate PDF and email it
    (async () => {
      try {
        const pdfBuffer = await generateReportPDF({
          company_name: role.company_name,
          job_title: role.job_title,
          role_introduction: role.role_introduction,
          screening_questions: role.screening_questions,
          screening_url
        });

        await transporter.sendMail({
          from: `"Screening Platform" <${process.env.SMTP_USER}>`,
          to: notification_email,
          subject: `Screening Created — ${role.job_title} at ${role.company_name}`,
          html: `
            <div style="font-family: system-ui, sans-serif; max-width: 560px; margin: 0 auto; padding: 32px 24px; color: #1E293B;">
              <div style="border-top: 4px solid #2563EB; padding-top: 24px; margin-bottom: 24px;"></div>
              <h1 style="font-size: 22px; margin: 0 0 4px;">Screening Created</h1>
              <p style="color: #64748B; margin: 0 0 24px; font-size: 14px;">Your new screening is ready to share.</p>

              <div style="background: #F1F5F9; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Company</p>
                <p style="margin: 0 0 12px; font-size: 15px; font-weight: 600;">${role.company_name}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Job Title</p>
                <p style="margin: 0; font-size: 15px; font-weight: 600;">${role.job_title}</p>
              </div>

              <p style="font-size: 14px; color: #64748B; margin: 0 0 8px;">Shareable screening link:</p>
              <a href="${screening_url}" style="display: block; background: #DBEAFE; color: #2563EB; padding: 10px 16px; border-radius: 6px; font-size: 13px; text-decoration: none; word-break: break-all;">${screening_url}</a>

              <p style="font-size: 13px; color: #94A3B8; margin: 32px 0 0; border-top: 1px solid #E2E8F0; padding-top: 16px;">
                A full PDF report is attached. Generated by Screening Platform.
              </p>
            </div>
          `,
          attachments: [
            {
              filename: `${role.company_name.replace(/\s+/g, '-')}_${role.job_title.replace(/\s+/g, '-')}_screening.pdf`,
              content: pdfBuffer,
              contentType: 'application/pdf'
            }
          ]
        });

        console.log(`PDF report emailed to ${notification_email}`);
      } catch (emailErr) {
        console.error('Failed to send PDF email:', emailErr.message);
      }
    })();

  } catch (error) {
    console.error('Error creating role:', error);
    res.status(500).json({ error: error.message });
  }
});

// LIST ROLES FOR AUTHENTICATED USER
app.get('/api/roles', verifyToken, async (req, res) => {
  try {
    const since = req.query.since ? new Date(req.query.since) : null;
    const result = await pool.query(
      `SELECT r.*,
              COUNT(s.id)::int AS submission_count,
              COUNT(CASE WHEN $2::timestamptz IS NULL OR s.submitted_at > $2::timestamptz THEN s.id END)::int AS new_submission_count
       FROM roles r
       LEFT JOIN screenings s ON s.role_id = r.id
       WHERE r.notification_email = $1
       GROUP BY r.id
       ORDER BY r.id DESC`,
      [req.user.email, since]
    );
    res.json({ roles: result.rows });
  } catch (error) {
    console.error('Error listing roles:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET ROLE BY SLUG
app.get('/api/roles/:slug', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM roles WHERE url_slug = $1',
      [req.params.slug]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Role not found' });
    }

    const role = result.rows[0];
    res.json({
      role_id: role.id,
      company_name: role.company_name,
      job_title: role.job_title,
      role_introduction: role.role_introduction,
      screening_questions: role.screening_questions
    });

  } catch (error) {
    console.error('Error fetching role:', error);
    res.status(500).json({ error: error.message });
  }
});

// UPDATE ROLE (intro / questions)
app.patch('/api/roles/:id', verifyToken, async (req, res) => {
  try {
    const { role_introduction, screening_questions, status } = req.body;
    const sets = [];
    const values = [];
    let idx = 1;

    if (role_introduction !== undefined) {
      sets.push(`role_introduction = $${idx++}`);
      values.push(role_introduction);
    }
    if (screening_questions !== undefined) {
      sets.push(`screening_questions = $${idx++}`);
      values.push(JSON.stringify(screening_questions));
    }
    if (status !== undefined) {
      sets.push(`status = $${idx++}`);
      values.push(status);
    }

    if (sets.length === 0) return res.status(400).json({ error: 'Nothing to update' });

    values.push(req.params.id);
    await pool.query(`UPDATE roles SET ${sets.join(', ')} WHERE id = $${idx}`, values);

    res.json({ status: 'updated' });
  } catch (error) {
    console.error('Error updating role:', error);
    res.status(500).json({ error: error.message });
  }
});

// SUBMIT SCREENING
app.post('/api/screenings', async (req, res) => {
  try {
    const {
      role_id,
      candidate_name,
      candidate_email,
      expected_salary_amount,
      expected_salary_currency,
      current_location,
      work_preference,
      visa_status,
      visa_sponsorship_details,
      notice_period_weeks,
      availability_start_date,
      role_specific_answers,
      recruiter_notes,
      recruiter_email
    } = req.body;

    const result = await pool.query(
      `INSERT INTO screenings (
        role_id, candidate_name, candidate_email,
        expected_salary_amount, expected_salary_currency,
        current_location, work_preference, visa_status,
        visa_sponsorship_details, notice_period_weeks,
        availability_start_date, role_specific_answers,
        recruiter_notes, recruiter_email
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      RETURNING *`,
      [
        role_id,
        candidate_name,
        candidate_email,
        expected_salary_amount,
        expected_salary_currency,
        current_location,
        work_preference,
        visa_status,
        visa_sponsorship_details,
        notice_period_weeks,
        availability_start_date,
        JSON.stringify(role_specific_answers),
        recruiter_notes,
        recruiter_email
      ]
    );

    res.json({
      screening_id: result.rows[0].id,
      status: 'submitted',
      submitted_at: result.rows[0].submitted_at
    });

    // Fire-and-forget: fetch role, generate PDF, email to notification_email
    (async () => {
      try {
        const roleResult = await pool.query('SELECT * FROM roles WHERE id = $1', [role_id]);
        if (roleResult.rows.length === 0) return;
        const role = roleResult.rows[0];
        if (!role.notification_email) return;

        const screening = result.rows[0];
        const pdfBuffer = await generateScreeningResultPDF({
          company_name: role.company_name,
          job_title: role.job_title,
          screening,
          role_specific_answers
        });

        await transporter.sendMail({
          from: `"Screening Platform" <${process.env.SMTP_USER}>`,
          to: role.notification_email,
          subject: `New Screening Submission — ${candidate_name} for ${role.job_title} at ${role.company_name}`,
          html: `
            <div style="font-family: system-ui, sans-serif; max-width: 560px; margin: 0 auto; padding: 32px 24px; color: #1E293B;">
              <div style="border-top: 4px solid #16A34A; padding-top: 24px; margin-bottom: 24px;"></div>
              <h1 style="font-size: 22px; margin: 0 0 4px;">New Screening Submission</h1>
              <p style="color: #64748B; margin: 0 0 24px; font-size: 14px;">A candidate has completed the screening.</p>

              <div style="background: #F1F5F9; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Candidate</p>
                <p style="margin: 0 0 4px; font-size: 15px; font-weight: 600;">${candidate_name}</p>
                <p style="margin: 0 0 12px; font-size: 13px; color: #2563EB;">${candidate_email}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Role</p>
                <p style="margin: 0; font-size: 15px; font-weight: 600;">${role.job_title} at ${role.company_name}</p>
              </div>

              <p style="font-size: 13px; color: #94A3B8; margin: 24px 0 0; border-top: 1px solid #E2E8F0; padding-top: 16px;">
                Full screening details are attached as a PDF. Generated by Screening Platform.
              </p>
            </div>
          `,
          attachments: [
            {
              filename: `${candidate_name.replace(/\s+/g, '-')}_${role.job_title.replace(/\s+/g, '-')}_submission.pdf`,
              content: pdfBuffer,
              contentType: 'application/pdf'
            }
          ]
        });

        console.log(`Screening submission PDF emailed to ${role.notification_email}`);
      } catch (emailErr) {
        console.error('Failed to send screening submission email:', emailErr.message);
      }
    })();

  } catch (error) {
    console.error('Error submitting screening:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET ALL SCREENINGS FOR A ROLE
app.get('/api/screenings/role/:roleId', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM screenings WHERE role_id = $1 ORDER BY submitted_at DESC',
      [req.params.roleId]
    );

    res.json({ screenings: result.rows });

  } catch (error) {
    console.error('Error fetching screenings:', error);
    res.status(500).json({ error: error.message });
  }
});

// AVAILABILITY — get
app.get('/api/availability', verifyToken, async (req, res) => {
  try {
    const { rows } = await pool.query('SELECT * FROM availability WHERE user_email = $1', [req.user.email]);
    res.json(rows[0] || { user_email: req.user.email, days: [], start_hour: 9, end_hour: 17 });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// AVAILABILITY — save
app.put('/api/availability', verifyToken, async (req, res) => {
  try {
    const { days, start_hour, end_hour } = req.body;
    await pool.query(
      `INSERT INTO availability (user_email, days, start_hour, end_hour)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (user_email) DO UPDATE SET days = EXCLUDED.days, start_hour = EXCLUDED.start_hour, end_hour = EXCLUDED.end_hour`,
      [req.user.email, days, start_hour, end_hour]
    );
    res.json({ status: 'saved' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// BOOKING SLOTS — public, generates available 15-min slots for next 14 days
app.get('/api/bookings/slots/:slug', async (req, res) => {
  try {
    const roleResult = await pool.query('SELECT * FROM roles WHERE url_slug = $1', [req.params.slug]);
    if (roleResult.rows.length === 0) return res.status(404).json({ error: 'Role not found' });
    const role = roleResult.rows[0];

    const availResult = await pool.query('SELECT * FROM availability WHERE user_email = $1', [role.notification_email]);
    if (availResult.rows.length === 0) {
      return res.json({ slots: [], role: { company_name: role.company_name, job_title: role.job_title } });
    }
    const avail = availResult.rows[0];

    // Collect date strings for next 14 days
    const today = new Date();
    const dateStrings = [];
    for (let d = 0; d < 14; d++) {
      const date = new Date(today);
      date.setDate(today.getDate() + d);
      dateStrings.push(date.toISOString().split('T')[0]);
    }

    // Fetch already-booked slots for this recruiter
    const bookingsResult = await pool.query(
      'SELECT booked_date, booked_time FROM bookings WHERE recruiter_email = $1 AND booked_date = ANY($2)',
      [role.notification_email, dateStrings]
    );
    const bookedSet = new Set(bookingsResult.rows.map(b => `${b.booked_date}T${b.booked_time}`));

    // Generate available slots
    const now = new Date();
    const slots = [];
    for (let d = 0; d < 14; d++) {
      const date = new Date(today);
      date.setDate(today.getDate() + d);
      const dayIndex = (date.getDay() + 6) % 7; // Mon=0 … Sun=6
      if (!avail.days.includes(dayIndex)) continue;

      const dateStr = dateStrings[d];
      for (let h = avail.start_hour; h < avail.end_hour; h++) {
        for (let m = 0; m < 60; m += 15) {
          if (d === 0) {
            const slotDate = new Date(today);
            slotDate.setHours(h, m, 0, 0);
            if (slotDate <= now) continue;
          }
          const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
          if (!bookedSet.has(`${dateStr}T${time}`)) {
            slots.push({ date: dateStr, time });
          }
        }
      }
    }

    res.json({ slots, role: { company_name: role.company_name, job_title: role.job_title } });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

function generateMeetLink() {
  return `https://meet.jit.si/Screening-${crypto.randomBytes(8).toString('base64url')}`;
}

function generateICS({ date, time, durationMinutes, summary, description, location }) {
  const [year, month, day] = date.split('-').map(Number);
  const [hour, minute] = time.split(':').map(Number);
  const pad = (n) => String(n).padStart(2, '0');
  const startStr = `${year}${pad(month)}${pad(day)}T${pad(hour)}${pad(minute)}00`;
  const endDate = new Date(year, month - 1, day, hour, minute + durationMinutes);
  const endStr = `${endDate.getFullYear()}${pad(endDate.getMonth() + 1)}${pad(endDate.getDate())}T${pad(endDate.getHours())}${pad(endDate.getMinutes())}00`;
  const uid = crypto.randomBytes(16).toString('hex') + '@screening-platform';
  const escaped = (s) => (s || '').replace(/\\/g, '\\\\').replace(/;/g, '\\;').replace(/,/g, '\\,').replace(/\n/g, '\\n');
  return [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Screening Platform//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    'BEGIN:VEVENT',
    `UID:${uid}`,
    `DTSTART:${startStr}`,
    `DTEND:${endStr}`,
    `SUMMARY:${escaped(summary)}`,
    `DESCRIPTION:${escaped(description)}`,
    `LOCATION:${escaped(location)}`,
    'END:VEVENT',
    'END:VCALENDAR'
  ].join('\r\n');
}

// CREATE BOOKING — public
app.post('/api/bookings', async (req, res) => {
  try {
    const { slug, candidate_name, candidate_email, booked_date, booked_time } = req.body;
    if (!slug || !candidate_name || !candidate_email || !booked_date || !booked_time) {
      return res.status(400).json({ error: 'All fields are required' });
    }

    const roleResult = await pool.query('SELECT * FROM roles WHERE url_slug = $1', [slug]);
    if (roleResult.rows.length === 0) return res.status(404).json({ error: 'Role not found' });
    const role = roleResult.rows[0];
    if (role.status !== 'open') return res.status(400).json({ error: 'This screening is closed' });

    const meet_link = generateMeetLink();

    const result = await pool.query(
      `INSERT INTO bookings (role_id, recruiter_email, candidate_name, candidate_email, booked_date, booked_time, meet_link)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [role.id, role.notification_email, candidate_name, candidate_email, booked_date, booked_time, meet_link]
    );

    res.json({ booking: result.rows[0] });

    // Fire-and-forget: notify recruiter
    (async () => {
      try {
        const formattedDate = new Date(booked_date + 'T12:00:00').toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
        const icsContent = generateICS({
          date: booked_date,
          time: booked_time,
          durationMinutes: 15,
          summary: `Screening Call — ${candidate_name} for ${role.job_title} at ${role.company_name}`,
          description: `15-minute screening call with ${candidate_name} (${candidate_email}).\n\nJoin Meeting: ${meet_link}`,
          location: meet_link
        });

        await transporter.sendMail({
          from: `"Screening Platform" <${process.env.SMTP_USER}>`,
          to: role.notification_email,
          subject: `New Booking — ${candidate_name} for ${role.job_title} at ${role.company_name}`,
          html: `
            <div style="font-family: system-ui, sans-serif; max-width: 560px; margin: 0 auto; padding: 32px 24px; color: #1E293B;">
              <div style="border-top: 4px solid #0d1b2a; padding-top: 24px; margin-bottom: 24px;"></div>
              <h1 style="font-size: 22px; margin: 0 0 4px;">New Screening Call Booked</h1>
              <p style="color: #64748B; margin: 0 0 24px; font-size: 14px;">A candidate has scheduled a call.</p>
              <div style="background: #F1F5F9; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Candidate</p>
                <p style="margin: 0 0 4px; font-size: 15px; font-weight: 600;">${candidate_name}</p>
                <p style="margin: 0 0 12px; font-size: 13px; color: #2563EB;">${candidate_email}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">Role</p>
                <p style="margin: 0 0 12px; font-size: 15px; font-weight: 600;">${role.job_title} at ${role.company_name}</p>
                <p style="margin: 0 0 2px; font-size: 13px; color: #64748B; text-transform: uppercase; letter-spacing: 0.05em;">When</p>
                <p style="margin: 0; font-size: 15px; font-weight: 600;">${formattedDate} at ${booked_time}</p>
              </div>
              <a href="${meet_link}" style="display: block; background: #1a73e8; color: #fff; text-align: center; padding: 12px 24px; border-radius: 6px; font-size: 14px; font-weight: 600; text-decoration: none; margin-bottom: 24px;">Join Meeting</a>
              <p style="font-size: 13px; color: #94A3B8; margin: 24px 0 0; border-top: 1px solid #E2E8F0; padding-top: 16px;">
                Generated by Screening Platform.
              </p>
            </div>
          `,
          attachments: [{
            filename: 'screening-call.ics',
            content: icsContent,
            contentType: 'text/calendar'
          }]
        });
        console.log(`Booking notification sent to ${role.notification_email}`);
      } catch (emailErr) {
        console.error('Failed to send booking notification:', emailErr.message);
      }
    })();
  } catch (error) {
    if (error.code === '23505') return res.status(409).json({ error: 'That time slot is no longer available. Please pick another.' });
    res.status(500).json({ error: error.message });
  }
});

// GET BOOKINGS FOR A ROLE — auth
app.get('/api/bookings/role/:roleId', verifyToken, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM bookings WHERE role_id = $1 ORDER BY booked_date ASC, booked_time ASC',
      [req.params.roleId]
    );
    res.json({ bookings: result.rows });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// GET SINGLE BOOKING — auth
app.get('/api/bookings/:id', verifyToken, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM bookings WHERE id = $1', [req.params.id]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'Booking not found' });
    res.json({ booking: result.rows[0] });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// UPLOAD RECORDING & TRANSCRIBE — auth
app.post('/api/bookings/:id/transcribe', verifyToken, upload.single('recording'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file uploaded' });
    if (!process.env.OPENAI_API_KEY) return res.status(500).json({ error: 'OPENAI_API_KEY is not configured' });

    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const { toFile } = require('openai');
    const audioFile = await toFile(req.file.buffer, req.file.originalname, { type: req.file.mimetype });

    const transcription = await openai.audio.transcriptions.create({
      file: audioFile,
      model: 'whisper-1'
    });

    await pool.query('UPDATE bookings SET transcript = $1 WHERE id = $2', [transcription.text, req.params.id]);

    res.json({ transcript: transcription.text });
  } catch (error) {
    console.error('Transcription error:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.listen(port, () => {
  console.log(`✅ Backend running on http://localhost:${port}`);
});